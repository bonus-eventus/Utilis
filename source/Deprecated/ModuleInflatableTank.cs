//
//  ModuleInflatableTank.cs
//
//  Author:
//       Bonus Eventus <>
//
//  Copyright (c) 2016 Bonus Eventus
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
//using System.Collections;
using System.Collections.Generic;
using UnityEngine;
namespace Utilis
{
	public class ModuleInflatableTank : PartModule
	{
		public ModuleInflatableTank ()
		{

		}

		[KSPEvent (active = true ,guiActive = true, guiName = "Deploy", guiActiveEditor = false, guiActiveUnfocused = true, unfocusedRange = 7.5f)]
		public void Deploy ()
		{
			//determine if in editor
			if(HighLogic.LoadedSceneIsFlight)
			{
				if (fairingTransform_1.gameObject != null && fairingTransform_2.gameObject != null)
				{
					//convert fairings to physical objects
					Rigidbody rigidbody = base.part.Rigidbody;

					if (rigidbody != null)
					{
						Vector3 heading_1 = fairingDeployPos_1 - fairingTransform_1.localPosition;

						Vector3 heading_2 = fairingDeployPos_2 - fairingTransform_2.localPosition;

						float step = 0f;

						while (fairingTransform_1.localPosition != heading_1) 
						{
							step += TimeWarp.fixedDeltaTime;

							fairingTransform_1.localPosition = Vector3.MoveTowards(fairingTransform_1.localPosition, heading_1, step);

							fairingTransform_2.localPosition = Vector3.MoveTowards(fairingTransform_2.localPosition, heading_2, step);

							Debug.Log(header + "fairingTransform_1.localPosition = "+fairingTransform_1.localPosition);
						}
						
						physicalObject physicalObject_1 = physicalObject.ConvertToPhysicalObject (base.part, fairingTransform_1.gameObject);
						
						physicalObject physicalObject_2 = physicalObject.ConvertToPhysicalObject (base.part, fairingTransform_2.gameObject);
						
						Rigidbody rb_1 = physicalObject_1.rb;
						
						Rigidbody rb_2 = physicalObject_2.rb;
						
						rb_1.maxAngularVelocity = PhysicsGlobals.MaxAngularVelocity;
						
						rb_2.maxAngularVelocity = PhysicsGlobals.MaxAngularVelocity;
						
						rb_1.angularVelocity = rigidbody.angularVelocity;
						
						rb_2.angularVelocity = rigidbody.angularVelocity;
						
						Vector3 lhs = base.vessel.CurrentCoM - rigidbody.worldCenterOfMass;
						
						rb_1.velocity = rigidbody.velocity + Vector3.Cross (lhs, rb_1.angularVelocity);
						
						rb_2.velocity = rigidbody.velocity + Vector3.Cross (lhs, rb_2.angularVelocity);
						
						rb_1.mass = fairingMass;
						
						rb_2.mass = fairingMass;
						
						rb_1.useGravity = true;
						
						rb_2.useGravity = true;
						
						rb_1.detectCollisions = false;
						
						rb_1.AddForceAtPosition (fairingDeployPos_1 * ejectionForce * 0.5f, base.transform.position, ForceMode.Force);
						
						rb_2.AddForceAtPosition (fairingDeployPos_2 * ejectionForce * 0.5f, base.transform.position, ForceMode.Force);
						
						base.part.AddForceAtPosition (-fairingDeployPos_1 * ejectionForce * 0.5f, base.transform.position);
						
						base.part.AddForceAtPosition (-fairingDeployPos_2 * ejectionForce * 0.5f, base.transform.position);
						
						fairingTemperatureRenderer_1 = null;
						
						fairingTemperatureRenderer_2 = null;
						
						deploying = true;

						base.Events["Deploy"].active = false;
						
						base.Actions["DeployAction"].active = false;
					}
				}else{
					Debug.Log(header+ " fairingTransform_1.gameObject or fairingTransform_2.gameObject is null.");
				}
			}else if(HighLogic.LoadedSceneIsEditor)
			{
				//editor deploy
			}
		}

		[KSPAction ("Deploy")]
		public void DeployAction (KSPActionParam param)
		{
			Deploy ();
		}

		//ksp fields

		[KSPField]
		public string deployAnimationName;

		[KSPField]
		public string deployName = "Deploy";

		[KSPField]
		public float fairingMass;

		[KSPField]
		public float ejectionForce;

		[KSPField]
		public string fairingName_1;

		[KSPField]
		public string fairingName_2;

		[KSPField]
		public Vector3 fairingDeployPos_1 = Vector3.forward;

		[KSPField]
		public Vector3 fairingDeployPos_2 = -Vector3.forward;

		[KSPField(isPersistant=true)]
		public bool isDeployed = false;

		[KSPField]
		public bool useMultipleDragCubes = true;

		//properties

		private Animation deployAnimation;

		private Transform fairingTransform_1;

		private Transform fairingTransform_2;

		private string header = "[ModuleInflatableTank]";

		public MaterialColorUpdater fairingTemperatureRenderer_1;

		public MaterialColorUpdater fairingTemperatureRenderer_2;

		private bool deploying = false;

		private float frame = 0f;

		private float maxFrame;

		//private PartResourceList backupResources = new PartResourceList(new Part());
		private List<ConfigNode> backupResources = new List<ConfigNode>();

		public bool IsMultipleCubesActive
		{
			get
			{
				return this.useMultipleDragCubes;
			}
		}

		//methods

		public override void OnAwake ()
		{
			base.OnAwake ();

		}

		public void AssumeDragCubePosition (string name)
		{

		}

		public override void OnStart (StartState state)
		{
			base.OnStart (state);

			part.fuelCrossFeed = false;
			if (deployName != string.Empty)
			{
				base.Events ["Deploy"].guiName = deployName;
				
				base.Actions ["DeployAction"].guiName = deployName;
			}
			
			if(deployAnimationName != string.Empty)
			{
				deployAnimation = part.FindModelAnimator(deployAnimationName);
				maxFrame = deployAnimation[deployAnimationName].length;
			}
			else{
				Debug.Log(header+" deployAnimationName string is empty. Check CFG file.");
			}
			
			if(fairingName_1 != string.Empty)
			{
				fairingTransform_1 = part.FindModelTransform(fairingName_1);
			}else{
				Debug.Log(header+" fairingName_1 string is empty. Check CFG file.");
			}
			
			if (fairingTransform_1 != null)
			{
				fairingTemperatureRenderer_1 = new MaterialColorUpdater (fairingTransform_1, PhysicsGlobals.TemperaturePropertyID);
			}
			
			if(fairingName_2 != string.Empty)
			{
				fairingTransform_2 = part.FindModelTransform(fairingName_2);
				
				if (fairingTransform_2 != null)
				{
					fairingTemperatureRenderer_2 = new MaterialColorUpdater (fairingTransform_2, PhysicsGlobals.TemperaturePropertyID);
				}
			}else{
				Debug.Log(header+" fairingName_2 string is empty. check CFG file");
			}

			if(HighLogic.LoadedSceneIsFlight)
			{
				if(isDeployed)
				{
					if(fairingTransform_1 != null && fairingTransform_2 != null)
					{
						fairingTransform_1.gameObject.DestroyGameObjectImmediate();

						fairingTransform_2.gameObject.DestroyGameObjectImmediate();
					}else{
						Debug.Log(header+" fairingTransform_1 is null or fairingTransform_2 is null. Check CFG file.");
					}
					if(deployAnimation != null)
					{
						deployAnimation[deployAnimationName].speed = 0;

						deployAnimation[deployAnimationName].normalizedTime = 1;

						deployAnimation[deployAnimationName].wrapMode = WrapMode.Once;

						deployAnimation.Play ();
					}else{
						Debug.Log(header+" deployAnimation is null. Check CFG file.");
					}

					base.Events["Deploy"].active = false;
					
					base.Actions["DeployAction"].active = false;
				}else{
					AlterResources(part.Resources, "remove");
				}
			}
		}

		private void AlterResources(PartResourceList prl, string opt)
		{
			switch(opt)
			{
			case "remove":
				if(prl != null)
				{
					int count = prl.Count;

					Debug.Log(header+" count = " + count.ToString());

					for(int i = 0; i < count; i++)
					{
						ConfigNode n = new ConfigNode();

						n.AddValue("name", prl[i].resourceName);

						n.AddValue ("amount", prl[i].amount);

						n.AddValue ("maxAmount", prl[i].maxAmount);

						n.AddValue ("isTweakable", prl[i].isTweakable);

						backupResources.Add(n);
					}
					prl.Clear();
				}else{
					Debug.Log(header+" PartResourceList is null. Make sure PartResource is defined in CFG file.");
				}
				break;
			case "reset":
				if(prl !=null)
				{
					prl.Clear();

					for(int i = 0; i<backupResources.Count; i++)
					{
						part.AddResource(backupResources[i]);
					}
				}else{
					Debug.Log(header+" PartResourceList is null. Make sure PartResource is defined in CFG file.");
				}

				break;
			}

		}

		public void FixedUpdate()
		{
			if(HighLogic.LoadedSceneIsFlight)
			{
				if(deploying)
				{
					if(frame <= maxFrame)
					{
						deployAnimation[deployAnimationName].time = frame;

						deployAnimation[deployAnimationName].speed = 0;

						deployAnimation[deployAnimationName].wrapMode = WrapMode.Once;

						deployAnimation.Play();

						frame += TimeWarp.fixedDeltaTime;
					}else{
						deploying = false;

						AlterResources(part.Resources, "reset");

						part.fuelCrossFeed = true;

						isDeployed = true;

					}
				}
			}
		}

		private void Update ()
		{
			if (fairingTemperatureRenderer_1 != null && !isDeployed)
			{
				if (HighLogic.LoadedSceneIsFlight)
				{
					if(fairingTemperatureRenderer_1 != null)fairingTemperatureRenderer_1.Update (PhysicsGlobals.GetBlackBodyRadiation ((float)base.part.skinTemperature, base.part), false);

					if(fairingTemperatureRenderer_2 != null)fairingTemperatureRenderer_2.Update (PhysicsGlobals.GetBlackBodyRadiation ((float)base.part.skinTemperature, base.part), false);
				}
				else
				{
					fairingTemperatureRenderer_1.Update (Color.clear, false);
				}
			}
		}

		public bool UsesProceduralDragCubes ()
		{
			return false;
		}
	}
}

