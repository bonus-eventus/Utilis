//
//  UtilisRendererList.cs
//
//  Author:Bonus Eventus
//
//  Contact: fortuneetbono@gmail.com
//
//  Copyright (c) 2018 Bonus Eventus
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;
namespace Utilis
{
	public class UtilisRendererList
	{
		public UtilisRendererList ()
		{
			_renderers = new List<Renderer>();
			_mpb = new MaterialPropertyBlock();
			Debug.Log("[Utilis][UtilisRenderList] _mbp MaterialPropertyBlock created");
		}

		public UtilisRendererList (List<Renderer> renderers) : this()
		{
			_renderers = renderers;
			if(renderers.Count <1 || renderers == null)throw new Exception("ERROR: List<renderers> argument in UtilisRenderList constructor requires at least 1 list item.");
		}

		public UtilisRendererList (List<Renderer> renderers, string property ) : this(renderers)
		{
			MatProp = property;
		}

		public UtilisRendererList (List<Renderer> renderers, string property, Color color ) : this(renderers, property)
		{
			MatProp = property;
			SetColor(color);
		}

		public UtilisRendererList (List<Renderer> renderers, string property, Color color, List<Renderer> excludeRenderers) : this(renderers, property, color)
		{
			if(excludeRenderers.Count <1 || renderers == null)
			{
				throw new Exception("ERROR: List<excludeRenderers> argument in UtilisRenderList constructor requires at least 1 list item.");
			}
			else{
				RemoveRange(excludeRenderers);
			}
		}

		public UtilisRendererList (List<Renderer> renderers, List<Renderer> excludeRenderers) : this(renderers)
		{
			if(excludeRenderers.Count <1 || renderers == null)
			{
				throw new Exception("ERROR: List<excludeRenderers> argument in UtilisRenderList constructor requires at least 1 list item.");
			}
			else{
				RemoveRange(excludeRenderers);
			}
		}

		public UtilisRendererList (List<Renderer> renderers, List<Renderer> excludeRenderers, string property) : this(renderers)
		{
			if(excludeRenderers.Count <1 || renderers == null)
			{
				throw new Exception("ERROR: List<excludeRenderers> argument in UtilisRenderList constructor requires at least 1 list item.");
			}
			else{
				RemoveRange(excludeRenderers);
			}
			MatProp = property;
		}

		private List<Renderer> _renderers;

		private string shaderProperty;

		private MaterialPropertyBlock _mpb;

		private int shaderPropertyInt;

		private void setMPB(Renderer renderer)
		{
			renderer.SetPropertyBlock(_mpb);
			//Debug.Log("[Utilis][UtilisRenderList] Renderer MaterialPropertyBlock color set.");
			//Debug.Log("[Utilis][UtilisRenderList] "+renderer.name+" MaterialPropertyBlock color set.");
		}

		public void SetColor(Color color)
		{
			_mpb.SetColor(shaderPropertyInt, color);
			//Debug.Log("[Utilis][UtilisRenderList] MaterialPropertyBlock color set to "+color.ToString());
			_renderers.ForEach(setMPB);
		}

		public string MatProp
		{
			get 
			{
				return shaderProperty;
			}

			set
			{
				shaderProperty = value;
				shaderPropertyInt = Shader.PropertyToID (value);
			}
		}

		public void Set(List<Renderer> list)
		{
			_renderers.Clear();
			_renderers = list;
		}

		public void RemoveRange(List<Renderer> renderers)
		{
			int count = _renderers.Count;
			while(count-- >0)
			{
				if(renderers.Contains(_renderers[count]))
				{
					_renderers.RemoveAt(count);
				}
			}
		}
	}
}

