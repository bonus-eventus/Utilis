//
//
//  Author:Bonus Eventus
//
//  Contact: fortuneetbono@gmail.com
//
//  Copyright (c) 2018 Bonus Eventus
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;
namespace Utilis
{
	public class ModuleCentrifuge : PartModule, IResourceConsumer
	{
		public ModuleCentrifuge ()
		{
			//animation curve used as the easing function for the rotation of the centrifuge
			this.f = AnimationCurve.EaseInOut(0f,0f,15f,6f);
		}

		//cfg

		//identifies this module for debug purposes
		private string moduleID = "ModuleCentrifuge";

		//this is a multiplier that will increase the g rating
		//basically it's cheating, by artificially increasing the 
		//centrifugal force [optional]
		[KSPField]
		public float gScale = 1f;

		//the name of the external pivot. This is the name of the transform that should be rotated
		[KSPField]
		public string pivot = "thePivot";

		//[optional] the name of the external counter torque ring pivot if any. Name of the transform that should be rotated.
		[KSPField]
		public string counterPivot = "theCounter";

		//[optional] speed multiplier for counter torque ring. default is 2x times pivot rotation speed.
		[KSPField]
		public float counterSpeedMult = 2f;

		//[optional] does this part have a coutner torque ring?
		[KSPField]
		public bool hasCounterTorque = true;

		//name of the deploy animation clip
		[KSPField]
		public string deployClipName;

		//speed of deploy animation playback
		[KSPField]
		public float deploySpeed = 1f;

		//amount of crew this centrifuge can carry
		[KSPField]
		public int crewCapacity = 1;

		//radius of the centrifuge in meters. Should be radius at 1:1 scale
		[KSPField]
		public float radius = 6f;

		//this part won't calculate G-Force if this is set to false
		[KSPField]
		public bool calculateG = true;

		//this part won't draw resources if this is set to false
		[KSPField]
		public bool drawRsources = true;


		//ui
		[KSPField(isPersistant=true, guiActive=true, guiName="Status", guiActiveEditor = false)]
		public string status = "Retracted";

		[KSPField (isPersistant=true, guiName = "Crew Capacity", guiActive = false, guiActiveEditor = false)]
		public int crew_capacity = 0;

		[KSPField (isPersistant=true, guiName = "G-Force", guiActive = false, guiActiveEditor = true)]
		public string gForce = "0.00G";

		[KSPField (isPersistant = true, guiName = "RPM", guiActive = false, guiActiveEditor = true), UI_FloatRange (stepIncrement = 0.1f, maxValue = 10f, minValue = 1f)]
		public float rpm;
		
		[KSPEvent (active = false, guiActive = false, guiName = "Transfer", guiActiveEditor = false)]
		public void Transfer ()
		{
			part.SpawnTransferDialog();
		}


		[KSPEvent (active = false ,guiActive = false, guiName = "Start", guiActiveEditor = true, guiActiveUnfocused = true, unfocusedRange = 7.5f)]
		public void Toggle ()
		{
			if(HighLogic.LoadedSceneIsFlight)
			{
				if (!toggleRotate)
				{
					//start rotate animation
					idle = false;
					startRotate = true;
					if(f.Evaluate((dt+=TimeWarp.fixedDeltaTime)) * 60f >= 360f)
					{
						
						status = "Rotating";
						rotate = true;
					}
					else
					{
						status = "Starting...";
						rotate = false;
					}
					//switch guiName
					base.Events["Toggle"].guiName = "Stop";
				}
				else{
					//stop rotate animation
					startRotate = false;
					rotate = false;
					if(dt >= f.keys[1].time)
					{
						dt = f.keys[1].time;
					}
					status = "Stopping...";
					//switch guiName
					base.Events["Toggle"].guiName = "Start";
				}
				toggleRotate = !toggleRotate;
			}
			else if(HighLogic.LoadedSceneIsEditor)
			{
				if (!toggleRotate)
				{
					//start rotate animation
					idle = false;
					startRotate = true;
					//switch guiName
					base.Events["Toggle"].guiName = "Stop";
				}
				else{
					//stop rotate animation
					startRotate = false;
					rotate = false;
					if(_dt >= f.keys[1].time)
					{
						_dt = f.keys[1].time;
					}
					//switch guiName
					base.Events["Toggle"].guiName = "Start";
				}
				toggleRotate = !toggleRotate;
			}
		}

		[KSPEvent (active = true ,guiActive = true, guiName = "Deploy", guiActiveEditor = true, guiActiveUnfocused = true, unfocusedRange = 7.5f)]
		public void Deploy ()
		{
			if(HighLogic.LoadedSceneIsFlight){
				//spawns iva and sets crew capacity
				if(part.internalModel == null)
				{
					part.CrewCapacity = crewCapacity;
					part.crewTransferAvailable = true;
					part.SpawnIVA ();
					//internalModel.SetVissible is false when there is no internalModel
					//if the iva overlay is present the internalModel mesh will be hidden 
					//unless this is set to true
				}
				crew_capacity = crewCapacity;
				status = "Deploying";

				//start deploy animation
				extAnim[deployClipName].speed = deploySpeed;
				extAnim[deployClipName].normalizedTime = 0f;
				extAnim[deployClipName].wrapMode = WrapMode.Once;
				extAnim.Play(deployClipName);
				isDeploying = true;

				//enable and make visible cenrifuge ui
				base.Events["Transfer"].guiActive = true;
				base.Events["Transfer"].active = true;
				if(calculateG)base.Fields["gForce"].guiActive = true;
				base.Fields["crew_capacity"].guiActive = true;
				base.Fields["rpm"].guiActive = true;
				base.Actions["ToggleAction"].active = true;
				base.Events["Toggle"].active = true;
				base.Events["Toggle"].guiActive = true;
				base.Actions["deployAction"].active = false;
				base.Events["Deploy"].active = false;
				base.Events["Deploy"].guiActive = false;
			}
			else if (HighLogic.LoadedSceneIsEditor)
			{
				if(!editorDeployToggle)
				{
					//start deploy animation
					extAnim[deployClipName].speed = deploySpeed;
					extAnim[deployClipName].normalizedTime = 0f;
					extAnim[deployClipName].wrapMode = WrapMode.Once;
					extAnim.Play(deployClipName);
					//switch guiName
					base.Events["Deploy"].guiName = "Retract";
					//switch active state
					base.Events["Toggle"].active = true;
				}
				else
				{
					//stop rotate animation
					startRotate = false;
					rotate = false;
					if(_dt >= f.keys[1].time)
					{
						_dt = f.keys[1].time;
					}
					//switch guiName
					base.Events["Toggle"].guiName = "Start";
					toggleRotate = !toggleRotate;

					//reverse deploy animation
					extAnim[deployClipName].speed = -1f;
					extAnim[deployClipName].normalizedTime = 0f;
					extAnim[deployClipName].wrapMode = WrapMode.Once;
					extAnim.Play(deployClipName);
					//switch guiName
					base.Events["Deploy"].guiName = "Deploy";
					//switch active state
					base.Events["Toggle"].active = false;
				}
				editorDeployToggle = !editorDeployToggle;
			}
		}

		[KSPAction ("Toggle")]
		public void ToggleAction (KSPActionParam param)
		{
			if(isDeployed)
			{
				Toggle ();
			}
			else
			{
				//haven't tested this yet [TEST THIS]
				ScreenMessage sm = new ScreenMessage("Centrifuge must first deployed!",2f,ScreenMessageStyle.UPPER_RIGHT);
				sm.color = new Color(1f,0.5f,0.125f,1f);
				ScreenMessages.PostScreenMessage(sm);
			}
		}

		[KSPAction ("Deploy")]
		public void deployAction (KSPActionParam param)
		{
			Deploy ();
		}

		//properties

		//deltaTime counter for flight scene
		[KSPField(isPersistant=true)]
		public float dt = 0f;

		//delatTime counter for the editor scene
		public float _dt = 0f;

		//stores the state of 'Toggle' event
		public bool toggleRotate = false;

		//stores the state of 'Deploy' event
		public bool toggleDeploy = false;

		//used for fixed update loop logic
		[KSPField(isPersistant=true)]
		public bool isDeployed = false;

		//signals the deploy animation has begun
		[KSPField(isPersistant=true)]
		public bool isDeploying = false;

		//used for fixed update loop logic
		public bool startRotate = false;

		//used for fixed update loop logic
		public bool rotate = false;

		//stores the rotation angle of centrifuge prior to accounting for time or revolutions per minute
		[KSPField(isPersistant=true)]
		public float angle = 0;

		//stores rotation angle of centrifuge prior for editor scene
		public float _angle = 0;

		//used for fixed update loop logic
		public bool idle = false;

		//used for fixed update lopp logic
		[KSPField(isPersistant=true)]
		public bool operational = true;

		//stores deployment state as string for loading persistance 
		//(enum states are not persistant by default; this is a hack. See OnLoad method.)
		[KSPField(isPersistant=true)]
		public string stored_dStatus;

		//stores the transform of the gameObject to rotate, 
		//This should never be part.transform. part.transform is the parent of too many things
		public Transform intTransform;

		//stores the transform of the gameObject to rotate, 
		//This should never be part.transform. part.transform is the parent of too many things
		public Transform extTransform;

		//[optional] stores the transform of the counter torque pivot gameObject.
		public Transform counterTransform;

		//relative centrifugal force = G
		[KSPField(isPersistant=true)]
		public float rcf;

		//rate multiplier for resource rate
		[KSPField(isPersistant=true)]
		public double mult;

		public bool editorDeployToggle = false;

		private List<PartResourceDefinition> consumedResources;

		//needed by IResourceConsumer interface
		public List<PartResourceDefinition> GetConsumedResources ()
		{
			return consumedResources;
		}

		public Animation extAnim;

		public float w;

		public int lastWarpIndex = 0;

		public int nextWarpIndex = 1;

		public float lastWarpRate;

		public float startLerpTime = 3000f;

		//these warpRates are more managable for rotations than the default TimeWarp rates
		public float[] warpRates = new float[] {1f,2f,3f,4f,6f,9f,12f,18f,24f,36f, 48f};

		//this switch inside the float transforms TimeWarp.CurentRate to a rotation friendly rate
		public float warp
		{
			get
			{
				switch((int)TimeWarp.CurrentRate)
				{
				case 1:
					lastWarpRate = 1f;
					lastWarpIndex = 0;
					nextWarpIndex = 1;
					startLerpTime = 3000f;
					w = 1f;
					break;
				case 2:
					lastWarpRate = 2f;
					lastWarpIndex = 1;
					nextWarpIndex = 2;
					startLerpTime = 3000f;
					w =  2f;
					break;
				case 3:
					lastWarpRate = 3f;
					lastWarpIndex = 2;
					nextWarpIndex = 3;
					startLerpTime = 3000f;
					w = 3f;
					break;
				case 4:
					lastWarpRate = 4f;
					lastWarpIndex = 3;
					nextWarpIndex = 4;
					startLerpTime = 3000f;
					w = 4f;
					break;
				case 5:
					lastWarpRate = 5f;
					lastWarpIndex = 4;
					nextWarpIndex = 5;
					startLerpTime = 3000f;
					w = 6f;
					break;
				case 10:
					lastWarpRate = 10f;
					lastWarpIndex = 5;
					nextWarpIndex = 6;
					startLerpTime = 3000f;
					w = 9f;
					break;
				case 50:
					lastWarpRate = 50f;
					lastWarpIndex = 6;
					nextWarpIndex = 7;
					startLerpTime = 3000f;
					w = 12f;
					break;
				case 100:
					lastWarpRate = 100f;
					lastWarpIndex = 7;
					nextWarpIndex = 8;
					startLerpTime = 3000f;
					w = 18f;
					break;
				case 1000:
					lastWarpRate = 1000f;
					lastWarpIndex = 8;
					nextWarpIndex = 9;
					startLerpTime = 3000f;
					w = 24f;
					break;
				case 10000:
					lastWarpRate = 10000f;
					lastWarpIndex = 9;
					nextWarpIndex = 10;
					startLerpTime = 3000f;
					w = 36f;
					break;
				case 100000:
					lastWarpRate = 100000f;
					lastWarpIndex = 10;
					nextWarpIndex = 10;
					startLerpTime = 3000f;
					w = 36f;
					break;
				default:
					if(startLerpTime == 3000f)startLerpTime = Time.time;
					if(lastWarpRate<TimeWarp.CurrentRate)
					{
						w = Mathf.Lerp(warpRates[lastWarpIndex],warpRates[nextWarpIndex],startLerpTime - Time.time);
					}
					else
					{
						w = Mathf.Lerp(warpRates[nextWarpIndex],warpRates[lastWarpIndex],startLerpTime - Time.time);
					}

					break;
				}
				return w;
			}

		}

		public AnimationCurve f = new AnimationCurve();

		//methods

		private void log(string func,string msg)
		{
			Debug.Log("["+moduleID+"] :"+func+": "+msg);
		}

		public override string GetInfo ()
		{
			return PartModuleUtil.PrintResourceRequirements("At 1G Requires","orange", resHandler.inputResources.ToArray());
		}

		//checks to see if the available resources are present
		public void hasResources()
		{
			if(rcf>0)
			{
				mult = (double)(rcf * 10 + 0.001f);
			}
			else 
			{
				mult = 0.001;
			}
			if (!resHandler.UpdateModuleResourceInputs (ref status, mult, 0.9, true, true))
			{
				startRotate = false;
				rotate = false;
				if(dt >= f.keys[1].time)
				{
					dt = f.keys[1].time;
				}
				operational = false;
				base.Events["Toggle"].guiActive = false;
				base.Events["Toggle"].active = false;
				toggleRotate = false;
			}
			else if(!operational)
			{
				status = "Idle";
				base.Events["Toggle"].guiName = "Start";
				base.Events["Toggle"].guiActive = true;
				base.Events["Toggle"].active = true;
				operational = false;
			}
		}
		
		public void GForce (float t)
		{
			//RPM to RCF or G Calculation is
			//G = (RPM/1000)e2 * Radius(mm) * 1118f 
			float RPM = (f.Evaluate((t))) * rpm;
			RPM = (RPM * 60f)/360f;
			RPM = Mathf.Pow(RPM/1000f,2f);
			float r =  radius * 1000f;
			rcf = 1.118f * r * RPM  * gScale;
			gForce = rcf.ToString ("F2") + "G";
			UtilisTools.Log(this,"dt = "+dt+",_dt =  "+_dt+",rpm = "+rpm+",RPM = "+RPM+",radius = "+radius+"rcf = "+rcf.ToString());
		}

		public override void OnAwake ()
		{
			base.OnAwake ();
			if (this.consumedResources == null)
			{
				this.consumedResources = new List<PartResourceDefinition> ();
			}
			else
			{
				this.consumedResources.Clear ();
			}
			int i = 0;
			int count = this.resHandler.inputResources.Count;
			while (i < count)
			{
				this.consumedResources.Add (PartResourceLibrary.Instance.GetDefinition (this.resHandler.inputResources [i].name));
				i++;
			}
		}

		public override void OnStart (StartState state)
		{
			base.OnStart (state);
			extTransform = part.FindModelTransform(pivot);
			if(hasCounterTorque)counterTransform = part.FindModelTransform(counterPivot);
			extAnim = part.FindModelAnimator(deployClipName);
			if(HighLogic.LoadedSceneIsFlight)
			{
				if(isDeployed)
				{
					//spawns iva and sets crew capacity
					if(part.internalModel == null)
					{
						part.CrewCapacity = crewCapacity;
						part.crewTransferAvailable = true;
						part.SpawnIVA ();
						//internalModel.SetVissible is false when there is no internalModel
						//if the iva overlay is present the internalModel mesh will be hidden 
						//unless this is set to true
						part.internalModel.SetVisible(true);
					}
					
					//start deploy animation
					extAnim[deployClipName].speed = 0f;
					extAnim[deployClipName].normalizedTime = 1f;
					extAnim[deployClipName].wrapMode = WrapMode.Once;
					extAnim.Play(deployClipName);
					isDeploying = false;
					crew_capacity = crewCapacity;

					//setup events and fields
					base.Events["Transfer"].guiActive = true;
					base.Events["Transfer"].active = true;
					if(calculateG) base.Fields["gForce"].guiActive = true;
					base.Fields["crew_capacity"].guiActive = true;
					base.Fields["rpm"].guiActive = true;
					base.Actions["ToggleAction"].active = true;
					base.Events["Toggle"].active = true;
					base.Events["Toggle"].guiActive = true;

					if(operational)
					{
						if(status == "Starting..." || status == "Rotating")
						{
							startRotate = true;
							rotate = true;
							base.Events["Toggle"].guiName = "Stop";
							//dt = 0f;
							toggleRotate = true;
						}
						if(status == "Stopping..." || status == "Starting..." || status == "Rotating")idle = false;

						if(status == "Stopping..." || status == "Idle")
						{
							startRotate = false;
							rotate = false;
							if(dt >= f.keys[1].time)
							{
								dt = f.keys[1].time;
							}
							base.Events["Toggle"].guiName = "Start";
							toggleRotate = false;
						}
						if(status == "Idle")
						{
							idle = true;
							gForce = "0.00G";
							dt = 0f;
						}
					}
					if(!operational)
					{
						startRotate = false;
						rotate = false;
						if(dt >= f.keys[1].time)
						{
							dt = f.keys[1].time;
						}
						operational = false;
						base.Events["Toggle"].guiActive = false;
						base.Events["Toggle"].active = false;
					}
					//setup events and fields
					base.Actions["deployAction"].active = false;
					base.Events["Deploy"].active = false;
					base.Events["Deploy"].guiActive = false;
					//set the transforms rotation state
					extTransform.localEulerAngles = new Vector3(0f,(angle*rpm*TimeWarp.fixedDeltaTime)/ TimeWarp.CurrentRate*warp,0f);
					if(part.internalModel!=null) part.internalModel.transform.localEulerAngles = new Vector3(90f,180f,(-1*angle*rpm*TimeWarp.deltaTime)/ TimeWarp.CurrentRate*warp);
				}
				else
				{
					base.Events["Deploy"].guiName = "Deploy";
					startRotate = false;
					idle = false;
					rotate = false;
					dt = 0;
					angle = 0;
				}

			}

		}

		public void FixedUpdate()
		{
			if(HighLogic.LoadedSceneIsFlight && isDeploying)
			{
				if(!extAnim.isPlaying)
				{
					status = "Deployed";
					if(part.internalModel == null)
					{
						part.CrewCapacity = crewCapacity;
						part.crewTransferAvailable = true;
						part.SpawnIVA ();
						//internalModel.SetVissible is false when there is no internalModel
						//if the iva overlay is present the internalModel mesh will be hidden 
						//unless this is set to true
						part.internalModel.SetVisible(true);
					}
					isDeploying = false;
					isDeployed = true;
				}
			}
			if(HighLogic.LoadedSceneIsFlight && isDeployed)
			{
				if(!idle)
				{
					if(startRotate)
					{

						if(calculateG) GForce (dt);

						extTransform.localEulerAngles = new Vector3(0f,(angle*rpm*TimeWarp.fixedDeltaTime)/ TimeWarp.CurrentRate*warp,0f);

						if(hasCounterTorque)counterTransform.localEulerAngles = new Vector3(0f,(angle*rpm*TimeWarp.fixedDeltaTime)/ TimeWarp.CurrentRate*warp*-1f*counterSpeedMult,0f);
						
						if(part.internalModel!=null) part.internalModel.transform.localEulerAngles = new Vector3(90f,180f,(-1*angle*rpm*TimeWarp.deltaTime)/ TimeWarp.CurrentRate*warp);
						
						if(!rotate)
						{
							if(f.Evaluate((dt+=TimeWarp.fixedDeltaTime)) * 60f >= 360f)
							{
								rotate=true;
								if(operational)status = "Rotating";
							}
						}
						if(drawRsources)hasResources ();

						angle+=f.Evaluate((dt+=TimeWarp.fixedDeltaTime));
					}
					else
					{
						if(calculateG) GForce (dt);

						extTransform.localEulerAngles = new Vector3(0f,(angle*rpm*TimeWarp.fixedDeltaTime),0f);

						if(hasCounterTorque)counterTransform.localEulerAngles = new Vector3(0f,(angle*rpm*-1f*counterSpeedMult*TimeWarp.fixedDeltaTime),0f);
						
						if(part.internalModel!=null) part.internalModel.transform.localEulerAngles = new Vector3(90f,180f,(-1*angle*rpm*TimeWarp.deltaTime)/ TimeWarp.CurrentRate*warp);

						if(drawRsources)hasResources ();

						if(f.Evaluate((dt-=TimeWarp.fixedDeltaTime)) <= 0f)
						{
							if(operational)status = "Idle";
							gForce = "0.00G";
							dt = 0f;
							idle = true;
						}
						angle+=f.Evaluate((dt-=TimeWarp.fixedDeltaTime));
					}
				}
				else if(!operational)
				{
					if(drawRsources)hasResources ();
				}
			}
			else if(HighLogic.LoadedSceneIsEditor)
			{
				if(!idle)
				{
					if(startRotate)
					{
						if(calculateG) GForce (_dt);

						extTransform.localEulerAngles = new Vector3(0f,(_angle*rpm*TimeWarp.fixedDeltaTime),0f);

						if(hasCounterTorque)counterTransform.localEulerAngles = new Vector3(0f,(_angle*rpm*-1f*counterSpeedMult*TimeWarp.fixedDeltaTime),0f);

						_angle+=f.Evaluate((_dt+=TimeWarp.fixedDeltaTime));
					}
					else
					{
						if(calculateG) GForce (_dt);

						extTransform.localEulerAngles = new Vector3(0f,(_angle*rpm*TimeWarp.fixedDeltaTime),0f);

						if(hasCounterTorque)counterTransform.localEulerAngles = new Vector3(0f,(_angle*rpm*-1f*counterSpeedMult*TimeWarp.fixedDeltaTime),0f);

						if(f.Evaluate((_dt-=TimeWarp.fixedDeltaTime)) <= 0f)
						{
							_dt = 0f;
							idle = true;
						}
						_angle+=f.Evaluate((_dt-=TimeWarp.fixedDeltaTime));
					}
				}
			}
		}

		public override void OnLoad (ConfigNode node)
		{
			//load resources (actually, turns out I don't need to. resHandler does this by itself. Cool)
		}
	}

}
